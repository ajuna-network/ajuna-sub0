//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Ajuna.NetApi;
using Ajuna.NetApi.Model.Extrinsics;
using Ajuna.NetApi.Model.Meta;
using Ajuna.NetApi.Model.Types;
using Ajuna.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace HelloKusama.NetApiExt.Generated.Storage
{
    
    
    public sealed class ParaSchedulerStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        public ParaSchedulerStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "ValidatorGroups"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.ValidatorIndex>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "ParathreadQueue"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.ParathreadClaimQueue)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "AvailabilityCores"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseOpt<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.EnumCoreOccupied>>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "ParathreadClaimIndex"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "SessionStartBlock"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Primitive.U32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("ParaScheduler", "Scheduled"), new System.Tuple<Ajuna.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.CoreAssignment>)));
        }
        
        /// <summary>
        /// >> ValidatorGroupsParams
        ///  All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
        ///  broader set of Polkadot validators, but instead just the subset used for parachains during
        ///  this session.
        /// 
        ///  Bound: The number of cores is the sum of the numbers of parachains and parathread multiplexers.
        ///  Reasonably, 100-1000. The dominant factor is the number of validators: safe upper bound at 10k.
        /// </summary>
        public static string ValidatorGroupsParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "ValidatorGroups", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ValidatorGroups
        ///  All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
        ///  broader set of Polkadot validators, but instead just the subset used for parachains during
        ///  this session.
        /// 
        ///  Bound: The number of cores is the sum of the numbers of parachains and parathread multiplexers.
        ///  Reasonably, 100-1000. The dominant factor is the number of validators: safe upper bound at 10k.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.ValidatorIndex>>> ValidatorGroups(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.ValidatorGroupsParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.ValidatorIndex>>>(parameters, token);
        }
        
        /// <summary>
        /// >> ParathreadQueueParams
        ///  A queue of upcoming claims and which core they should be mapped onto.
        /// 
        ///  The number of queued claims is bounded at the `scheduling_lookahead`
        ///  multiplied by the number of parathread multiplexer cores. Reasonably, 10 * 50 = 500.
        /// </summary>
        public static string ParathreadQueueParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "ParathreadQueue", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ParathreadQueue
        ///  A queue of upcoming claims and which core they should be mapped onto.
        /// 
        ///  The number of queued claims is bounded at the `scheduling_lookahead`
        ///  multiplied by the number of parathread multiplexer cores. Reasonably, 10 * 50 = 500.
        /// </summary>
        public async Task<HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.ParathreadClaimQueue> ParathreadQueue(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.ParathreadQueueParams();
            return await _client.GetStorageAsync<HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.ParathreadClaimQueue>(parameters, token);
        }
        
        /// <summary>
        /// >> AvailabilityCoresParams
        ///  One entry for each availability core. Entries are `None` if the core is not currently occupied. Can be
        ///  temporarily `Some` if scheduled but not occupied.
        ///  The i'th parachain belongs to the i'th core, with the remaining cores all being
        ///  parathread-multiplexers.
        /// 
        ///  Bounded by the maximum of either of these two values:
        ///    * The number of parachains and parathread multiplexers
        ///    * The number of validators divided by `configuration.max_validators_per_core`.
        /// </summary>
        public static string AvailabilityCoresParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "AvailabilityCores", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> AvailabilityCores
        ///  One entry for each availability core. Entries are `None` if the core is not currently occupied. Can be
        ///  temporarily `Some` if scheduled but not occupied.
        ///  The i'th parachain belongs to the i'th core, with the remaining cores all being
        ///  parathread-multiplexers.
        /// 
        ///  Bounded by the maximum of either of these two values:
        ///    * The number of parachains and parathread multiplexers
        ///    * The number of validators divided by `configuration.max_validators_per_core`.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseOpt<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.EnumCoreOccupied>>> AvailabilityCores(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.AvailabilityCoresParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<Ajuna.NetApi.Model.Types.Base.BaseOpt<HelloKusama.NetApiExt.Generated.Model.polkadot_primitives.v2.EnumCoreOccupied>>>(parameters, token);
        }
        
        /// <summary>
        /// >> ParathreadClaimIndexParams
        ///  An index used to ensure that only one claim on a parathread exists in the queue or is
        ///  currently being handled by an occupied core.
        /// 
        ///  Bounded by the number of parathread cores and scheduling lookahead. Reasonably, 10 * 50 = 500.
        /// </summary>
        public static string ParathreadClaimIndexParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "ParathreadClaimIndex", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> ParathreadClaimIndex
        ///  An index used to ensure that only one claim on a parathread exists in the queue or is
        ///  currently being handled by an occupied core.
        /// 
        ///  Bounded by the number of parathread cores and scheduling lookahead. Reasonably, 10 * 50 = 500.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>> ParathreadClaimIndex(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.ParathreadClaimIndexParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>>(parameters, token);
        }
        
        /// <summary>
        /// >> SessionStartBlockParams
        ///  The block number where the session start occurred. Used to track how many group rotations have occurred.
        /// 
        ///  Note that in the context of parachains modules the session change is signaled during
        ///  the block and enacted at the end of the block (at the finalization stage, to be exact).
        ///  Thus for all intents and purposes the effect of the session change is observed at the
        ///  block following the session change, block number of which we save in this storage value.
        /// </summary>
        public static string SessionStartBlockParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "SessionStartBlock", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> SessionStartBlock
        ///  The block number where the session start occurred. Used to track how many group rotations have occurred.
        /// 
        ///  Note that in the context of parachains modules the session change is signaled during
        ///  the block and enacted at the end of the block (at the finalization stage, to be exact).
        ///  Thus for all intents and purposes the effect of the session change is observed at the
        ///  block following the session change, block number of which we save in this storage value.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Primitive.U32> SessionStartBlock(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.SessionStartBlockParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Primitive.U32>(parameters, token);
        }
        
        /// <summary>
        /// >> ScheduledParams
        ///  Currently scheduled cores - free but up to be occupied.
        /// 
        ///  Bounded by the number of cores: one for each parachain and parathread multiplexer.
        /// 
        ///  The value contained here will not be valid after the end of a block. Runtime APIs should be used to determine scheduled cores/
        ///  for the upcoming block.
        /// </summary>
        public static string ScheduledParams()
        {
            return RequestGenerator.GetStorage("ParaScheduler", "Scheduled", Ajuna.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> Scheduled
        ///  Currently scheduled cores - free but up to be occupied.
        /// 
        ///  Bounded by the number of cores: one for each parachain and parathread multiplexer.
        /// 
        ///  The value contained here will not be valid after the end of a block. Runtime APIs should be used to determine scheduled cores/
        ///  for the upcoming block.
        /// </summary>
        public async Task<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.CoreAssignment>> Scheduled(CancellationToken token)
        {
            string parameters = ParaSchedulerStorage.ScheduledParams();
            return await _client.GetStorageAsync<Ajuna.NetApi.Model.Types.Base.BaseVec<HelloKusama.NetApiExt.Generated.Model.polkadot_runtime_parachains.scheduler.CoreAssignment>>(parameters, token);
        }
    }
    
    public sealed class ParaSchedulerCalls
    {
    }
}
